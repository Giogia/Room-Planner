{"version":3,"file":"StaticShadow.js","sourceRoot":"","sources":["../../src/three-components/StaticShadow.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright 2018 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {DirectionalLight, Mesh, MeshBasicMaterial, OrthographicCamera, PlaneGeometry, RGBAFormat, Scene, Vector3, WebGLRenderTarget} from 'three';\nimport {WebGLRenderer} from 'three';\n\nexport interface ShadowGenerationConfig {\n  near?: number;\n  far?: number;\n  textureWidth?: number;\n  textureHeight?: number;\n}\n\nconst $camera = Symbol('camera');\nconst $renderTarget = Symbol('renderTarget');\n\nconst scale = new Vector3();\n\nconst BASE_SHADOW_OPACITY = 0.1;\n\nconst DEFAULT_CONFIG: ShadowGenerationConfig = {\n  near: 0.01,\n  far: 100,\n  textureWidth: 512,\n  textureHeight: 512,\n};\n\nconst shadowGeneratorMaterial = new MeshBasicMaterial({\n  color: 0x000000,\n});\n\nconst shadowTextureMaterial = new MeshBasicMaterial({\n  transparent: true,\n  opacity: BASE_SHADOW_OPACITY,\n});\n\n/**\n * Creates a mesh that can receive and render pseudo-shadows\n * only updated when calling its render method. This is different\n * from non-auto-updating shadows because the resulting material\n * applied to the mesh is disconnected from the renderer's shadow map\n * and can be freely rotated and positioned like a regular texture.\n */\nexport default class StaticShadow extends Mesh {\n  private[$renderTarget]: WebGLRenderTarget;\n  private[$camera]: OrthographicCamera;\n  /**\n   * Create a shadow mesh.\n   */\n  constructor() {\n    const geometry = new PlaneGeometry(1, 1);\n    geometry.rotateX(-Math.PI / 2);\n\n    super(geometry, shadowTextureMaterial.clone());\n    this.name = 'StaticShadow';\n\n    this[$renderTarget] = new WebGLRenderTarget(\n        DEFAULT_CONFIG.textureWidth!, DEFAULT_CONFIG.textureHeight!, {\n          format: RGBAFormat,\n        });\n    (this.material as any).map = this[$renderTarget].texture;\n    (this.material as any).needsUpdate = true;\n\n    this[$camera] = new OrthographicCamera(-1, 1, 1, -1);\n  }\n\n  get intensity(): number {\n    return (this.material as any).opacity / BASE_SHADOW_OPACITY;\n  }\n\n  set intensity(intensity: number) {\n    const intensityIsNumber =\n        typeof intensity === 'number' && !(self as any).isNaN(intensity);\n\n    (this.material as any).opacity =\n        BASE_SHADOW_OPACITY * (intensityIsNumber ? intensity : 0.0);\n\n    this.visible = (this.material as any).opacity > 0;\n  }\n\n  /**\n   * Updates the generated static shadow. The size of the camera is dependent\n   * on the current scale of the StaticShadow that will host the texture.\n   * It's expected for the StaticShadow to be facing the light source.\n   *\n   * @param {THREE.WebGLRenderer} renderer\n   * @param {THREE.Scene} scene\n   * @param {THREE.DirectionalLight} light\n   * @param {Object} config\n   * @param {number} config.near\n   * @param {number} config.far\n   * @param {number} config.textureWidth\n   * @param {number} config.textureHeight\n   */\n  render(\n      renderer: WebGLRenderer, scene: Scene, light: DirectionalLight,\n      config: ShadowGenerationConfig = {}) {\n    const userSceneOverrideMaterial = scene.overrideMaterial;\n    const userSceneBackground = scene.background;\n    const userClearAlpha = renderer.getClearAlpha();\n    const userRenderTarget = renderer.getRenderTarget();\n    const shadowParent = this.parent;\n\n    config = Object.assign({}, config, DEFAULT_CONFIG);\n\n    renderer.setClearAlpha(0);\n    scene.overrideMaterial = shadowGeneratorMaterial;\n    scene.background = null;\n\n    // Update render target size if necessary\n    if (this[$renderTarget].width !== config.textureWidth ||\n        this[$renderTarget].height !== config.textureHeight) {\n      this[$renderTarget].setSize(config.textureWidth!, config.textureHeight!);\n    }\n\n    // Set the camera to where the light source is,\n    // and facing its target.\n    light.updateMatrixWorld(true);\n    light.target.updateMatrixWorld(true);\n\n    this[$camera].position.setFromMatrixPosition(light.matrixWorld);\n    this[$camera].updateMatrixWorld(true);\n    this[$camera].lookAt(light.target.position);\n\n    // Update the camera's frustum to fully engulf the StaticShadow\n    // mesh that will be rendering the generated texture.\n    this.updateMatrixWorld(true);\n    scale.setFromMatrixScale(this.matrixWorld);\n\n    this[$camera].top = scale.z / 2;\n    this[$camera].bottom = scale.z / -2;\n    this[$camera].left = scale.x / -2;\n    this[$camera].right = scale.x / 2;\n    this[$camera].near = config.near!;\n    this[$camera].far = config.far!;\n    this[$camera].updateProjectionMatrix();\n\n    // There's a chance the shadow will be in the scene that's being rerendered;\n    // temporarily remove it incase.\n    if (shadowParent) {\n      shadowParent.remove(this);\n    }\n\n    renderer.setRenderTarget(this[$renderTarget]);\n    renderer.clear();\n    renderer.render(scene, this[$camera]);\n\n    if (shadowParent) {\n      shadowParent.add(this);\n    }\n\n    (this.material as any).needsUpdate = true;\n\n    // Reset the values on the renderer and scene\n    scene.overrideMaterial = userSceneOverrideMaterial;\n    scene.background = userSceneBackground;\n    renderer.setClearAlpha(userClearAlpha);\n    renderer.setRenderTarget(userRenderTarget);\n  }\n}\n"]}